{
  "name": "coffee-coverage",
  "description": "JSCoverage-style instrumentation for CoffeeScript files.",
  "keywords": [
    "javascript",
    "coffeescript",
    "coverage",
    "code coverage",
    "test"
  ],
  "version": "0.1.4",
  "author": {
    "name": "Benbria",
    "url": "http://www.benbria.com/"
  },
  "contributors": [
    {
      "name": "Jason Walton",
      "email": "dev@lucid.thedreaming.org",
      "url": "https://github.com/jwalton"
    },
    {
      "name": "Drew Stokes",
      "email": "drew@drewstokes.com",
      "url": "https://github.com/dstokes"
    },
    {
      "name": "Vyacheslav Slinko",
      "email": "vyacheslav.slinko@gmail.com",
      "url": "https://github.com/vslinko"
    },
    {
      "name": "David Dahl",
      "url": "https://github.com/effata"
    }
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/benbria/coffee-coverage/master/LICENSE"
    }
  ],
  "main": "./lib/coffeeCoverage",
  "bin": {
    "coffeeCoverage": "./bin/coffeecoverage"
  },
  "directories": {
    "lib": "./lib"
  },
  "dependencies": {
    "coffee-script": ">=1.6.2",
    "pkginfo": ">=0.2.3",
    "argparse": ">=0.1.7"
  },
  "engines": {
    "node": ">=0.6.19"
  },
  "readme": "Benbria CoffeeCoverage\n======================\n\nCompiles .coffee files to .js files, and adds [JSCoverage](http://siliconforks.com/jscoverage/)\nstyle instrumnetation for the original coffee script source.\n\nContents\n--------\n\n*   [Installation and a Quick Intro](#installation-and-a-quick-intro)\n*   [What it Does](#what-it-does)\n*   [How it Works](#how-it-works)\n*   [Using with Mocha and Node.js](#using-with-mocha-and-nodejs)\n*   [Some Weirdness with Line Numbers](#some-weirdness-with-line-numbers)\n*   [Detailed Usage](#detailed-usage)\n\n\nWhat it Does\n------------\n\nBenbria CoffeeCoverage takes a collection of .coffee files, and produces .js files which have been\ninstrumented to record how many times each line is executed.  Given a file \"hello.coffee\":\n\n    console.log \"Hello World\"\n\nIt produces output that looks something like this (edited slightly for brevity and readability):\n\n    // coffeecoverage generated initialization\n    if (! _$jscoverage[\"hello.coffee\"]) {\n        _$jscoverage[\"hello.coffee\"] = [];\n        _$jscoverage[\"hello.coffee\"][1] = 0;\n    }\n    _$jscoverage[\"hello.coffee\"].source = [\"console.log \\\"Hello World\\\"\", \"\"];\n\n    (function() {\n\n      _$jscoverage[\"hello.coffee\"][1]++; // Count that we're executing line #1\n      console.log(\"Hello World\");\n\n    }).call(this);\n\nThe output is intentionally similar to that of [JSCoverage](http://siliconforks.com/jscoverage/),\nso that your source can be used with existing coverage-analysis tools.\n\n\nInstallation and a Quick Intro\n------------------------------\n\nInstall with:\n\n    npm install -g coffee-coverage\n\nGiven a directory \"source\" full of .coffee files, run:\n\n    coffeecoverage ./source ./dest\n\nThis will recursively find all the .coffee files in the \"source\" directory, and produce .js files\nin the \"dest\" directory.  Note that you can compile in-place with:\n\n    coffeecoverage ./source ./source\n\n\nHow it Works\n------------\nSee the [Design](https://github.com/benbria/coffee-coverage/wiki/Design) page on the Wiki.\n\n\nUsing with Mocha and Node.js\n----------------------------\n\nAt Benbria, we use CoffeeCoverage to find out how much coverage we get from our unit tests.  Our\nprocess works like this; first we make a copy of our code base:\n\n    cd project\n    mkdir /tmp/coverage\n    tar -cf - . | (cd /tmp/coverage && tar -xf -)\n    cd /tmp/coverage\n\nThen we instrument it in-place.  We exclude the \"test\" directory, since we don't want coverage of\nour actual test code:\n\n    coffeecoverage --initfile init.js --exclude node_modules,.git,test --path abbr . .\n\nWe don't have to delete the .coffee files, since when we `require 'foo'`, node will preferentially\nload the foo.js file over the foo.coffee file.  coffeecoverage nicely gives us the number of lines\nit instrumented - this is handy, because if we never `require` a given file from our tests, it\nwon't show up in the mocha report.\n\nNext we run our tests:\n\n    mocha --require init.js --reporter html-cov --compilers coffee:coffee-script test/*Test.coffee\n\nSome Weirdness with Line Numbers\n--------------------------------\n\nThis snippet of CoffeeScript:\n\n    if x then y() \\\n         else z()\n\ngets compile to this snippet of JavaScript:\n\n    if (x) {\n      y();\n    } else {\n      z();\n    }\n\nWe have three statements we could annotate here; the \"if\" itself, the call to y, and the call to z.\nThe problem is that both the \"if\" an the call to \"y()\" are on the same line of CoffeeScript source.\nIf we annotate both the \"if\" and the \"y()\", then if `x` is true, we will count two executions of the\nfirst line of the CoffeeScript, even though we've only run this chunk of CoffeeScript once.\n\nCoffeeCoverage tries to work around this by only instrumenting the first statement it finds on a\nline, so in the above example, we'd annotate the \"if\" and the \"z()\", but not the \"y()\".\n\nDetailed Usage\n--------------\n\nUsage: `coffeecoverage [-h] [-v] [-c name] [-e filenames] [-i initfile] [--path pathtype] src dest`\n\n`src` and `dest` are the source file or directory and destination file or directory, respectively.\nIf `src` is a .coffee file, then coffeecoverage will instrument the file and write the result to\n`dest` (e.g. `coffeecoverage a.coffee a.js`.)  If `src` is a directory, then coffeecoverage will\nrecursively walk through `src` finding .coffee files, and writing them into the `dest`, creating\nany subdirectories in `dest` as required.  If `src` and `dest` are the same directory, then all the\n.coffee files in `src` will have .js files written alongside them.\n\n### Optional arguments:\n\n#### -c, --coverageVar\n\nBy default, coffeecoverage will instrument source files with the global variable \"_$jscoverage\".\nThis is done to mimic JSCoverage.  You can rename this variable by using this option.\n\n#### -i, --initfile\n\nSpecifies an \"initfile\" which all global initalization is written to.  This is handy for testing\nwith mocha.  If you `require` the initfile, then mocha reports will show coverage of all files in\nyour project, even files which were never required anywhere.\n\n#### -e, --exclude\n\nGives a comma delimited list of files and directories to exclude from processing.  This defaults\nto 'node_modules,.git', since neither of these are directories you probably want to be\ninstrumenting.  If you want to also exclude your \"test\" directory, you might run coffeecoverage\nwith:\n\n    coffeecoverage --exclude 'node_modules,.git,test' ...\n\n#### --path\n\nPath can be given one of three different parameters:\n\n - `none` is the default - if coffeecoverage reads a file from \"src/models/user.coffee\", then\n   the instrumented code will use the filename \"user.coffee\".  This works well provided you\n   don't reuse filenames elsewhere in your code.  Note that if there is a name collision between\n   two files in different subdirectories, coffeecoverage will append a something to the\n   end of one to make it unique, otherwise coverage data from one file would interfere with data\n   from another.\n - `abbr` will use abbreviated path names; a file from \"src/models/user.coffee\" will be\n   instrumented as \"s/m/user.coffee\".\n - `relative` will use the full relative pathname; \"src/models/user.coffee\".\n\nPaths are always relative to the `src` directory provided on the command line.\n",
  "readmeFilename": "README.md",
  "_id": "coffee-coverage@0.1.4",
  "_from": "coffee-coverage@0.1.4"
}
