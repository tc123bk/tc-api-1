// Generated by CoffeeScript 1.6.3
var JsonSchema, ValidationErrors, amanda, crypto, errors, jsonPointer, json_schema_options, sylables,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

amanda = require('amanda');

crypto = require('crypto');

jsonPointer = require('json-pointer');

ValidationErrors = require('./validation-errors').ValidationErrors;

errors = require('../errors');

sylables = ['a', 'e', 'i', 'o', 'u'];

json_schema_options = {
  singleError: false,
  messages: {
    'minLength': function(prop, val, validator) {
      return "The " + prop + " property must be at least " + validator + " characters long (currently " + val.length + " characters long).";
    },
    'maxLength': function(prop, val, validator) {
      return "The " + prop + " property must not exceed " + validator + " characters (currently " + val.length + " characters long).";
    },
    'length': function(prop, val, validator) {
      return "The " + prop + " property must be exactly " + validator + " characters long (currently " + val.length + " characters long).";
    },
    'format': function(prop, val, validator) {
      var _ref;
      return "The " + prop + " property must be " + ((_ref = validator[0].toLowerCase(), __indexOf.call(sylables, _ref) >= 0) ? 'an' : 'a') + " " + validator + " (current value is " + (JSON.stringify(val)) + ").";
    },
    'type': function(prop, val, validator) {
      var _ref;
      return "The " + prop + " property must be " + ((_ref = validator[0].toLowerCase(), __indexOf.call(sylables, _ref) >= 0) ? 'an' : 'a') + " " + validator + " (current value is " + (JSON.stringify(val)) + ").";
    },
    'except': function(prop, val, validator) {
      return "The " + prop + " property must not be " + val + ".";
    },
    'minimum': function(prop, val, validator) {
      return "The minimum value of the " + prop + " must be " + validator + " (current value is " + (JSON.stringify(val)) + ").";
    },
    'maximum': function(prop, val, validator) {
      return "The maximum value of the " + prop + " must be " + validator + " (current value is " + (JSON.stringify(val)) + ").";
    },
    'pattern': function(prop, val, validator) {
      return "The " + prop + " value (" + val + ") does not match the " + validator + " pattern.";
    },
    'maxItems': function(prop, val, validator) {
      return "The " + prop + " property must not contain more than " + validator + " items (currently contains " + val.length + " items).";
    },
    'minItems': function(prop, val, validator) {
      return "The " + prop + " property must contain at least " + validator + " items (currently contains " + val.length + " items).";
    },
    'divisibleBy': function(prop, val, validator) {
      return "The " + prop + " property is not divisible by " + validator + " (current value is " + (JSON.stringify(val)) + ").";
    },
    'uniqueItems': function(prop, val, validator) {
      return "All items in the " + prop + " property must be unique.";
    }
  }
};

JsonSchema = (function() {
  function JsonSchema(data, schema) {
    var error, outError;
    this.data = data;
    this.schema = schema;
    if (typeof this.data === 'string') {
      try {
        this.data = JSON.parse(this.data);
      } catch (_error) {
        error = _error;
        outError = new errors.DataNotJsonParsableError('JSON validator: body: ' + error.message);
        outError['data'] = this.data;
        throw outError;
      }
    }
    if (typeof this.schema === 'string') {
      try {
        this.schema = JSON.parse(schema);
      } catch (_error) {
        error = _error;
        outError = new errors.SchemaNotJsonParsableError('JSON validator: schema: ' + error.message);
        outError['schema'] = this.schema;
        throw outError;
      }
    }
  }

  JsonSchema.prototype.validate = function() {
    var dataHash, error, schemaHash;
    if (((this.data instanceof Object) && Object.keys(this.data).length === 0) || ((this.data instanceof Object) && this.schema['empty'])) {
      error = {
        "length": 0,
        "errorMessages": {}
      };
      return new ValidationErrors(error);
    }
    dataHash = this.getHash(this.data);
    schemaHash = this.getHash(this.schema);
    if (this.dataHash === dataHash && this.schemaHash === schemaHash) {
      return this.errors;
    } else {
      this.dataHash = dataHash;
      this.schemaHash = schemaHash;
    }
    return this.validatePrivate();
  };

  JsonSchema.evaluateOutputToResults = function(data) {
    var indexes, results, _i, _ref, _results;
    results = [];
    if (data === null) {
      return results;
    }
    if (data.length > 0) {
      indexes = (function() {
        _results = [];
        for (var _i = 0, _ref = data.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
      indexes.forEach(function(index) {
        var item, message;
        item = data[index];
        console.error;
        message = {
          pointer: jsonPointer.compile(item['property']),
          severity: 'error',
          message: item.message
        };
        return results.push(message);
      });
    }
    return results;
  };

  JsonSchema.prototype.validatePrivate = function() {
    var error,
      _this = this;
    try {
      return amanda.validate(this.data, this.schema, json_schema_options, function(error) {
        return _this.errors = new ValidationErrors(error);
      });
    } catch (_error) {
      error = _error;
      error = {
        "0": {
          "property": [],
          "attributeValue": true,
          "message": "Validator internal error: " + error.message,
          "validatorName": "error"
        },
        "length": 1,
        "errorMessages": {}
      };
      return this.errors = new ValidationErrors(error);
    }
  };

  JsonSchema.prototype.getHash = function(data) {
    return crypto.createHash('md5').update(JSON.stringify(data)).digest('hex');
  };

  return JsonSchema;

})();

module.exports = {
  JsonSchema: JsonSchema
};
