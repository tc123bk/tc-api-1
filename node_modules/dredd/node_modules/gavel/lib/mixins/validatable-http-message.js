// Generated by CoffeeScript 1.6.3
var async, errors, extendable, validatable, validators;

async = require('async');

errors = require('../errors');

extendable = require('../utils/extendable').extendable;

validators = require('../validators');

validatable = {
  validatableComponents: ['headers', 'body', 'statusCode'],
  validate: function() {
    this.validation = {};
    if (this.headers !== void 0) {
      this.validateHeaders();
    }
    if (this.body !== void 0) {
      this.validateBody();
    }
    if (this.statusCode !== void 0) {
      this.validateStatusCode();
    }
    return this.validation;
  },
  isValidatable: function() {
    var result,
      _this = this;
    result = false;
    this.validatableComponents.forEach(function(component) {
      if (_this[component] !== void 0) {
        return result = true;
      }
    });
    return result;
  },
  isValid: function() {
    var output,
      _this = this;
    output = true;
    if (this.validation === void 0) {
      this.validate();
    }
    this.validatableComponents.forEach(function(component) {
      if (_this.validation[component] !== void 0) {
        if (Array.isArray(_this.validation[component].results)) {
          return _this.validation[component].results.forEach(function(result) {
            if (result['severity'] === 'error') {
              return output = false;
            }
          });
        }
      }
    });
    return output;
  },
  validationResults: function() {
    if (this.validation === void 0) {
      this.validate();
    }
    return this.validation;
  },
  validateHeaders: function() {
    this.validation.headers = {};
    this.validation.headers.results = [];
    this.setHeadersRealType();
    this.setHeadersExpectedType();
    this.setHeadersValidator();
    this.runHeadersValidator();
    return this.setHeadersResults();
  },
  setHeadersRealType: function() {
    if (this.headers instanceof Object && !Array.isArray(this.headers)) {
      return this.validation.headers.realType = "application/vnd.apiary.http-headers+json";
    } else {
      return this.validation.headers.realType = null;
    }
  },
  setHeadersExpectedType: function() {
    if (this.expected.headers instanceof Object && !Array.isArray(this.expected.headers)) {
      return this.validation.headers.expectedType = "application/vnd.apiary.http-headers+json";
    } else {
      return this.validation.headers.expectedType = null;
    }
  },
  setHeadersValidator: function() {
    var entry;
    if (this.validation.headers.realType === "application/vnd.apiary.http-headers+json" && this.validation.headers.expectedType === "application/vnd.apiary.http-headers+json") {
      return this.validation.headers.validator = "HeadersJsonExample";
    } else {
      this.validation.headers.validator = null;
      if (this.validation.headers.results === void 0) {
        this.validation.headers.results = [];
      }
      entry = {
        severity: 'error',
        message: 'No validator found for real data media type "' + +JSON.stringify(this.validation.headers.realType) + '" and expected data media type "' + +JSON.stringify(this.validation.headers.expectedType) + '".'
      };
      return this.validation.headers.results.push(entry);
    }
  },
  runHeadersValidator: function() {
    var validator, validatorClass;
    if (this.validation.headers.validator === null) {
      return this.validation.headers.rawData = null;
    } else {
      validatorClass = validators[this.validation.headers.validator];
      validator = new validatorClass(this.headers, this.expected.headers);
      return this.validation.headers.rawData = validator.validate();
    }
  },
  setHeadersResults: function() {
    var results, validatorClass;
    if (!Array.isArray(this.validation.headers.results)) {
      this.validation.headers.results = [];
    }
    if (this.validation.headers.rawData !== null) {
      validatorClass = validators[this.validation.headers.validator];
      results = validatorClass.evaluateOutputToResults(this.validation.headers.rawData);
      return this.validation.headers.results = results.concat(this.validation.headers.results);
    }
  },
  validateBody: function() {
    this.validation.body = {};
    this.validation.body.results = [];
    this.setBodyRealType();
    this.setBodyExpectedType();
    this.setBodyValidator();
    this.runBodyValidator();
    return this.setBodyResults();
  },
  setBodyRealType: function() {
    var error, isJsonContentType, message;
    this.validation.body.realType = null;
    if (typeof this.body !== 'string') {
      throw new Error("HTTP Body is not a String.");
    }
    isJsonContentType = false;
    if (!(this.headers === void 0) && !(this.headers['content-type'] === void 0)) {
      isJsonContentType = this.headers['content-type'].split(';')[0] === 'application/json';
    }
    if (isJsonContentType) {
      try {
        JSON.parse(this.body);
        return this.validation.body.realType = 'application/json';
      } catch (_error) {
        error = _error;
        message = {
          message: 'Unknown real body media type. Content-type header is "application/json" but body is not a parseble JSON.',
          severity: 'error'
        };
        return this.validation.body.results.push(message);
      }
    } else {
      try {
        JSON.parse(this.body);
        return this.validation.body.realType = 'application/json';
      } catch (_error) {
        error = _error;
        return this.validation.body.realType = 'text/plain';
      }
    }
  },
  setBodyExpectedType: function() {
    var error, isJsonContentType, message, parsed;
    this.validation.body.expectedType = null;
    if (this.validation.body.results === void 0) {
      this.validation.body.results = [];
    }
    if (!(this.expected.bodySchema === void 0) && !(this.expected.bodySchema === null)) {
      if (typeof this.expected.bodySchema === 'string') {
        try {
          parsed = JSON.parse(this.expected.bodySchema);
          if (typeof parsed !== 'object' || Array.isArray(parsed)) {
            message = {
              message: 'Expected:JSON Schema provided, but it is not an Object',
              severity: 'error'
            };
            return this.validation.body.results.push(message);
          } else {
            return this.validation.body.expectedType = 'application/schema+json';
          }
        } catch (_error) {
          error = _error;
          message = {
            message: 'Expected: JSON Schema provided, but it is not a parseable JSON',
            severity: 'error'
          };
          this.validation.body.results.push(message);
        }
      } else {
        return this.validation.body.expectedType = 'application/schema+json';
      }
    } else {
      isJsonContentType = false;
      if (!(this.expected.headers === void 0) && !(this.expected.headers['content-type'] === void 0)) {
        isJsonContentType = this.expected.headers['content-type'].split(';')[0] === 'application/json';
      }
      if (isJsonContentType) {
        try {
          JSON.parse(this.expected.body);
          return this.validation.body.expectedType = 'application/json';
        } catch (_error) {
          error = _error;
          message = {
            message: 'Expected: Content-Type is application/json but body is not a parseable JSON ',
            severity: 'error'
          };
          return this.validation.body.results.push(message);
        }
      } else {
        try {
          JSON.parse(this.expected.body);
          return this.validation.body.expectedType = 'application/json';
        } catch (_error) {
          error = _error;
          return this.validation.body.expectedType = 'text/plain';
        }
      }
    }
  },
  setBodyValidator: function() {
    var message;
    this.validation.body.validator = null;
    if (this.validation.body.results === void 0) {
      this.validation.body.results = [];
    }
    if (this.validation.body.realType === null && this.validation.body.expectedType === null) {
      message = {
        message: 'Unknown real and expected type. No validator found.',
        severity: 'error'
      };
      return this.validation.body.results.push(message);
    } else {
      if (this.validation.body.realType === 'application/json') {
        if (this.validation.body.expectedType === 'application/json') {
          return this.validation.body.validator = 'JsonExample';
        } else if (this.validation.body.expectedType === 'application/schema+json') {
          return this.validation.body.validator = 'JsonSchema';
        } else {
          message = {
            message: "No validator found for real data media type '" + this.validation.body.realType + "' and expected data media type '" + this.validation.body.expectedType + "'.",
            severity: 'error'
          };
          return this.validation.body.results.push(message);
        }
      } else if (this.validation.body.realType === 'text/plain') {
        if (this.validation.body.expectedType === 'text/plain') {
          return this.validation.body.validator = 'TextDiff';
        } else {
          message = {
            message: "No validator found for real data media type '" + this.validation.body.realType + "' and expected data media type '" + this.validation.body.expectedType + "'.",
            severity: 'error'
          };
          return this.validation.body.results.push(message);
        }
      } else {
        message = {
          message: "No validator found for real data media type '" + this.validation.body.realType + "' and expected data media type '" + this.validation.body.expectedType + "'.",
          severity: 'error'
        };
        return this.validation.body.results.push(message);
      }
    }
  },
  runBodyValidator: function() {
    var expected, real, validator, validatorClass;
    if (this.validation.body.validator === null) {
      return this.validation.body.rawData = null;
    } else {
      validatorClass = validators[this.validation.body.validator];
      if (this.validation.body.validator === 'JsonSchema') {
        real = this.body;
        expected = this.expected.bodySchema;
      } else {
        real = this.body;
        expected = this.expected.body;
      }
      validator = new validatorClass(real, expected);
      return this.validation.body.rawData = validator.validate();
    }
  },
  setBodyResults: function() {
    var results, validatorClass;
    if (this.validation.body.validator !== null) {
      if (!Array.isArray(this.validation.body.results)) {
        this.validation.body.results = [];
      }
      validatorClass = validators[this.validation.body.validator];
      results = validatorClass.evaluateOutputToResults(this.validation.body.rawData);
      return this.validation.body.results = results.concat(this.validation.body.results);
    }
  },
  validateStatusCode: function() {
    var expected, real, results, validator;
    this.validation.statusCode = {};
    this.validation.statusCode.realType = "text/vnd.apiary.status-code";
    this.validation.statusCode.expectedType = "text/vnd.apiary.status-code";
    this.validation.statusCode.validator = 'TextDiff';
    real = String(this.statusCode).trim();
    expected = String(this.expected.statusCode).trim();
    validator = new validators.TextDiff(real, expected);
    this.validation.statusCode.rawData = validator.validate();
    this.validation.statusCode.results = [];
    results = validators.TextDiff.evaluateOutputToResults(this.validation.statusCode.rawData);
    return this.validation.statusCode.results = results.concat(this.validation.statusCode.results);
  }
};

Function.prototype.actAsValidatable = function() {
  return extendable.include(validatable, this);
};
